// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: books.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addBookToShelf = `-- name: AddBookToShelf :exec
INSERT INTO shelf_books (shelf_id, isbn13, google_id, title, thumbnail_url)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (shelf_id, google_id) DO NOTHING
`

type AddBookToShelfParams struct {
	ShelfID      pgtype.UUID
	Isbn13       string
	GoogleID     string
	Title        string
	ThumbnailUrl pgtype.Text
}

func (q *Queries) AddBookToShelf(ctx context.Context, arg AddBookToShelfParams) error {
	_, err := q.db.Exec(ctx, addBookToShelf,
		arg.ShelfID,
		arg.Isbn13,
		arg.GoogleID,
		arg.Title,
		arg.ThumbnailUrl,
	)
	return err
}

const createShelf = `-- name: CreateShelf :one
INSERT INTO shelves (userid, title, description)
VALUES ($1, $2, $3)
RETURNING id, userid, title, description, created_at, updated_at
`

type CreateShelfParams struct {
	Userid      pgtype.UUID
	Title       string
	Description pgtype.Text
}

func (q *Queries) CreateShelf(ctx context.Context, arg CreateShelfParams) (Shelf, error) {
	row := q.db.QueryRow(ctx, createShelf, arg.Userid, arg.Title, arg.Description)
	var i Shelf
	err := row.Scan(
		&i.ID,
		&i.Userid,
		&i.Title,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBooksInShelf = `-- name: GetBooksInShelf :many
SELECT shelf_id, isbn13, google_id, title, thumbnail_url, added_at FROM shelf_books
WHERE shelf_id = $1
ORDER BY added_at DESC
`

func (q *Queries) GetBooksInShelf(ctx context.Context, shelfID pgtype.UUID) ([]ShelfBook, error) {
	rows, err := q.db.Query(ctx, getBooksInShelf, shelfID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ShelfBook
	for rows.Next() {
		var i ShelfBook
		if err := rows.Scan(
			&i.ShelfID,
			&i.Isbn13,
			&i.GoogleID,
			&i.Title,
			&i.ThumbnailUrl,
			&i.AddedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getShelvesByUser = `-- name: GetShelvesByUser :many
SELECT id, userid, title, description, created_at, updated_at FROM SHELVES
WHERE userid = $1
ORDER BY created_at DESC
`

func (q *Queries) GetShelvesByUser(ctx context.Context, userid pgtype.UUID) ([]Shelf, error) {
	rows, err := q.db.Query(ctx, getShelvesByUser, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Shelf
	for rows.Next() {
		var i Shelf
		if err := rows.Scan(
			&i.ID,
			&i.Userid,
			&i.Title,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserLogs = `-- name: GetUserLogs :many
SELECT id, userid, isbn13, google_id, title, thumbnail_url, status, rating, review, created_at, updated_at FROM book_logs
WHERE userid = $1
ORDER BY updated_at DESC
`

func (q *Queries) GetUserLogs(ctx context.Context, userid pgtype.UUID) ([]BookLog, error) {
	rows, err := q.db.Query(ctx, getUserLogs, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BookLog
	for rows.Next() {
		var i BookLog
		if err := rows.Scan(
			&i.ID,
			&i.Userid,
			&i.Isbn13,
			&i.GoogleID,
			&i.Title,
			&i.ThumbnailUrl,
			&i.Status,
			&i.Rating,
			&i.Review,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertBookLog = `-- name: UpsertBookLog :one
INSERT INTO book_logs (userid, isbn13, google_id, title, thumbnail_url, status, rating, review)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
ON CONFLICT (userid, google_id)
DO UPDATE SET 
    status = EXCLUDED.status,
    rating = EXCLUDED.rating,
    review = EXCLUDED.review,
    updated_at = NOW()
RETURNING id, userid, isbn13, google_id, title, thumbnail_url, status, rating, review, created_at, updated_at
`

type UpsertBookLogParams struct {
	Userid       pgtype.UUID
	Isbn13       string
	GoogleID     string
	Title        string
	ThumbnailUrl string
	Status       string
	Rating       pgtype.Float4
	Review       pgtype.Text
}

func (q *Queries) UpsertBookLog(ctx context.Context, arg UpsertBookLogParams) (BookLog, error) {
	row := q.db.QueryRow(ctx, upsertBookLog,
		arg.Userid,
		arg.Isbn13,
		arg.GoogleID,
		arg.Title,
		arg.ThumbnailUrl,
		arg.Status,
		arg.Rating,
		arg.Review,
	)
	var i BookLog
	err := row.Scan(
		&i.ID,
		&i.Userid,
		&i.Isbn13,
		&i.GoogleID,
		&i.Title,
		&i.ThumbnailUrl,
		&i.Status,
		&i.Rating,
		&i.Review,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
